<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PixelArena Snake Ranked 1v1</title>
<style>
body{margin:0;background:#7c8f00;font-family:monospace;text-align:center}
canvas{background:#9bbc0f;margin-top:20px}
#info{margin-top:10px;font-weight:bold}
#timer{margin-top:5px}
</style>
</head>
<body>

<h2>üêç PixelArena Snake Ranked 1v1</h2>
<div id="info">Rakip aranƒ±yor...</div>
<div id="timer"></div>
<canvas id="game" width="300" height="300"></canvas>

<script type="module">

import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
import { getFirestore, doc, getDoc, updateDoc, increment } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
import { getDatabase, ref, set, get, remove, onValue, onDisconnect } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

const firebaseConfig = {
  apiKey:"AIzaSyBykwXCOJpX6rG0pUx93HmALjVcCQWVMYA",
  authDomain:"emirhan-site.firebaseapp.com",
  projectId:"emirhan-site",
  storageBucket:"emirhan-site.firebasestorage.app",
  messagingSenderId:"668871888390",
  appId:"1:668871888390:web:76568bda84cb1641f7bd87"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const rtdb = getDatabase(app);

let currentUser;
let roomId=null;
let opponentId=null;
let gameStartTime=null;
let gameDuration=60000;
let isPlaying=false;
let alreadyMatched=false;

const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
const box=15;
const size=300;

let snake,dir,food,score;

onAuthStateChanged(auth,user=>{
if(!user){
alert("Giri≈ü gerekli");
return;
}
currentUser=user;
joinQueue();
});

async function joinQueue(){

const userRef=doc(db,"users",currentUser.uid);
const snap=await getDoc(userRef);

if(!snap.exists()){
alert("Firestore users dok√ºmanƒ± yok!");
return;
}

const elo=snap.data().elo || 1000;

await set(ref(rtdb,"rankedQueue/"+currentUser.uid),{
elo:elo,
joinedAt:Date.now()
});

listenForMatch(elo);
}

function listenForMatch(myElo){

const queueRef = ref(rtdb,"rankedQueue");

onValue(queueRef, snap=>{
if(!snap.exists() || alreadyMatched) return;

const queue = snap.val();

for(let uid in queue){

if(uid === currentUser.uid) continue;

if(Math.abs(queue[uid].elo - myElo) <= 100){

// k√º√ß√ºk UID oda kurar (√ßakƒ±≈üma √∂nleme)
if(currentUser.uid < uid){
createRoom(uid);
}

alreadyMatched=true;
break;
}

}

});
}

async function createRoom(opponent){

if(roomId) return;

roomId="room_"+Date.now();
opponentId=opponent;

await set(ref(rtdb,"gameRooms/"+roomId),{
status:"playing",
startTime:Date.now(),
players:{
[currentUser.uid]:{score:0,connected:true},
[opponent]:{score:0,connected:true}
}
});

await remove(ref(rtdb,"rankedQueue/"+currentUser.uid));
await remove(ref(rtdb,"rankedQueue/"+opponent]);

listenRoom();
startLocalGame();
}

function listenRoom(){

const roomRef=ref(rtdb,"gameRooms/"+roomId);

onDisconnect(ref(rtdb,"gameRooms/"+roomId+"/players/"+currentUser.uid))
.update({connected:false});

onValue(roomRef,snap=>{
if(!snap.exists()) return;

const data=snap.val();
gameStartTime=data.startTime;
const players=data.players;

for(let uid in players){
if(uid!==currentUser.uid){
opponentId=uid;

if(players[uid].connected===false){
alert("Rakip baƒülantƒ±yƒ± kaybetti. Kazandƒ±n!");
finishMatch(true);
}
}
}

if(Date.now()-data.startTime>gameDuration){
finishMatch(null);
}
});
}

function startLocalGame(){
snake=[{x:150,y:150}];
dir="RIGHT";
food=randomFood();
score=0;
isPlaying=true;
document.getElementById("info").innerText="Ma√ß ba≈üladƒ±!";
requestAnimationFrame(loop);
}

function randomFood(){
return{
x:Math.floor(Math.random()*(size/box))*box,
y:Math.floor(Math.random()*(size/box))*box
};
}

function loop(){
if(!isPlaying) return;

update();
draw();

if(roomId){
set(ref(rtdb,"gameRooms/"+roomId+"/players/"+currentUser.uid+"/score"),score);
}

let timeLeft=Math.max(0,Math.floor((gameDuration-(Date.now()-gameStartTime))/1000));
document.getElementById("timer").innerText="S√ºre: "+timeLeft;

requestAnimationFrame(loop);
}

function update(){
let headX=snake[0].x;
let headY=snake[0].y;

if(dir==="UP")headY-=box;
if(dir==="DOWN")headY+=box;
if(dir==="LEFT")headX-=box;
if(dir==="RIGHT")headX+=box;

if(headX<0||headY<0||headX>=size||headY>=size||collision(headX,headY)){
isPlaying=false;
return;
}

if(headX===food.x&&headY===food.y){
score++;
food=randomFood();
}else{
snake.pop();
}

snake.unshift({x:headX,y:headY});
}

function draw(){
ctx.fillStyle="#9bbc0f";
ctx.fillRect(0,0,size,size);

snake.forEach(s=>{
ctx.fillStyle="#0f380f";
ctx.fillRect(s.x,s.y,box,box);
});

ctx.fillText("üçé",food.x+7,food.y+7);
}

function collision(x,y){
return snake.some(s=>s.x===x&&s.y===y);
}

document.addEventListener("keydown",e=>{
if(e.key==="ArrowUp"&&dir!=="DOWN")dir="UP";
if(e.key==="ArrowDown"&&dir!=="UP")dir="DOWN";
if(e.key==="ArrowLeft"&&dir!=="RIGHT")dir="LEFT";
if(e.key==="ArrowRight"&&dir!=="LEFT")dir="RIGHT";
});

async function finishMatch(forceWin){

if(!roomId) return;

isPlaying=false;

const snap=await get(ref(rtdb,"gameRooms/"+roomId));
if(!snap.exists()) return;

const players=snap.val().players;

let myScore=players[currentUser.uid].score;
let oppScore=players[opponentId]?.score || 0;

let win=false;

if(forceWin===true){
win=true;
}else if(forceWin===null){
if(myScore>oppScore) win=true;
}

if(win){
alert("Kazandƒ±n!");
await updateElo(currentUser.uid,opponentId);
}else{
alert("Kaybettin!");
}

await remove(ref(rtdb,"gameRooms/"+roomId));
roomId=null;
}

async function updateElo(winner,loser){

await updateDoc(doc(db,"users",winner),{
elo:increment(25),
wins:increment(1),
totalGames:increment(1)
});

await updateDoc(doc(db,"users",loser),{
elo:increment(-20),
losses:increment(1),
totalGames:increment(1)
});
}

</script>
</body>
</html>
